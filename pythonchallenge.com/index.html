<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<h1 id="challenge-00">Challenge 00</h1>
<p>This one is so straight forward its hardly worth archiving</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main <span class="fu">=</span> <span class="fu">print</span> <span class="fu">$</span> <span class="dv">2</span> <span class="fu">^</span> <span class="dv">38</span></code></pre>
<h1 id="challenge-01">Challenge 01</h1>
<p>This challenge presents us with an encrypted message and a picture which implies the message has been encoded with a Caesar cipher.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Monad</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Function</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Char</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>)
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Maybe</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></code></pre>
<p>We'll represent the cipher as a map of characters onto characters. This makes deciphering a string a simple matter of lookups.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Cipher</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Char</span> <span class="dt">Char</span></code></pre>
<p>Take a list and rotate is by <code>n</code> elements to the right. This function helps us build the map we use to represent the cipher.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> rotate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">&gt;</span> rotate n xs <span class="fu">=</span> <span class="fu">take</span> (<span class="fu">length</span> xs) <span class="fu">.</span> <span class="fu">drop</span> n <span class="fu">$</span> <span class="fu">cycle</span> xs</code></pre>
<p>Build a substitution cipher from the step size. We take various character ranges we want to substitute over, in this case all lower and capital letters, and zip this resulting list with a precisely rotated version of itself and build a map out of it.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> cipher ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cipher</span>
<span class="fu">&gt;</span> cipher step <span class="fu">=</span> M.fromList <span class="fu">$</span> [lower, upper] <span class="fu">&gt;&gt;=</span> <span class="fu">zip</span> <span class="ot">`ap`</span> rotate step
<span class="fu">&gt;</span>   <span class="kw">where</span> lower <span class="fu">=</span> [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>]
<span class="fu">&gt;</span>         upper <span class="fu">=</span> [<span class="ch">&#39;A&#39;</span><span class="fu">..</span><span class="ch">&#39;Z&#39;</span>]</code></pre>
<p>Attempt to substitute letters. Since our cipher is nothing more than just a map, lets look up the letter in the map, and should we fail to find it return the input. This lets us substitute letters efficiently while persevering punctuation.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> substitute ::</span> <span class="dt">Cipher</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="fu">&gt;</span> substitute <span class="fu">=</span> ap fromMaybe <span class="fu">.</span> <span class="fu">flip</span> M.lookup</code></pre>
<p>This deciphers the string. Its a simple matter of running substitute over every single letter in the string.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> decipher ::</span> <span class="dt">Cipher</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="fu">&gt;</span> decipher <span class="fu">=</span> <span class="fu">map</span> <span class="fu">.</span> substitute</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main <span class="fu">=</span> decipher c <span class="fu">&lt;$&gt;</span> <span class="fu">getContents</span> <span class="fu">&gt;&gt;=</span> <span class="fu">putStrLn</span>
<span class="fu">&gt;</span>   <span class="kw">where</span> c <span class="fu">=</span> cipher <span class="fu">$</span> <span class="ch">&#39;K&#39;</span> <span class="ot">`step`</span> <span class="ch">&#39;M&#39;</span></code></pre>
<p>Calculate the difference between two letters since we given a hint at the offset used for this cipher.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> step ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">&gt;</span> step <span class="fu">=</span> <span class="fu">abs</span> <span class="fu">.:</span> (<span class="fu">-</span>) <span class="ot">`on`</span> <span class="fu">ord</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> (<span class="fu">.:</span>) <span class="fu">=</span> (<span class="fu">.</span>) <span class="fu">.</span> (<span class="fu">.</span>)</code></pre>
<h1 id="challenge-02">Challenge 02</h1>
<p>For this challenge we are presented with a large block of characters and the challenge is to find the rare characters. To solve this challenge we first calculate the frequency of each letter and then filter out any letter that occurs too frequently.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Char</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>)
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">System.Environment</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></code></pre>
<p>Some types to help us: <code>FrequencyMap</code> to store the frequency of the letters and <code>CharSet</code> to represent a set of letters.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">FrequencyMap</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Char</span> <span class="dt">Int</span>
<span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">CharSet</span> <span class="fu">=</span> <span class="dt">Set</span> <span class="dt">Char</span></code></pre>
<p>Here we calculate the frequency of each letter in a message.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> freqMap ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">FrequencyMap</span>
<span class="fu">&gt;</span> freqMap <span class="fu">=</span> <span class="fu">foldr</span> (M.alter count) M.empty
<span class="fu">&gt;</span>   <span class="kw">where</span> count <span class="fu">=</span> <span class="fu">return</span> <span class="fu">.</span> <span class="fu">maybe</span> <span class="dv">1</span> (<span class="fu">+</span> <span class="dv">1</span>)</code></pre>
<p>Now build a set containing only those characters in the frequency map who fall below a threshold.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> lowFreqSet ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FrequencyMap</span> <span class="ot">-&gt;</span> <span class="dt">CharSet</span>
<span class="fu">&gt;</span> lowFreqSet c <span class="fu">=</span> M.keysSet <span class="fu">.</span> M.filter (<span class="fu">&lt;=</span> c)</code></pre>
<p>Here we do the filtering. First it builds a set of all characters which do not appear frequently in the string and then filters out all <em>other</em> characters which are <em>not</em> members of this set.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> freqFilter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="fu">&gt;</span> freqFilter f <span class="fu">=</span> <span class="fu">flip</span> S.member <span class="fu">.</span> lowFreqSet f <span class="fu">.</span> freqMap <span class="fu">&gt;&gt;=</span> <span class="fu">filter</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main <span class="fu">=</span> getArgs <span class="fu">&gt;&gt;=</span> parse <span class="fu">&gt;&gt;=</span> \f <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>     freqFilter f <span class="fu">&lt;$&gt;</span> <span class="fu">getContents</span> <span class="fu">&gt;&gt;=</span> <span class="fu">putStrLn</span>
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span><span class="ot">     parse ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
<span class="fu">&gt;</span>     parse []    <span class="fu">=</span> <span class="fu">return</span> <span class="dv">10</span>
<span class="fu">&gt;</span>     parse (x<span class="fu">:</span>_) <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="fu">read</span> x</code></pre>
<h1 id="challenge-03">Challenge 03</h1>
<p>We are looking for each letter in the centre of the pattern: <code>xXXXxXXXx</code> (where <code>x</code> represents any lower case letter and <code>X</code> any upper case letter).</p>
<p>It seems like the author expected this challenge to be solved with regular expressions. I have chosen, for practise, to attempt a solution with Parsecs instead.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span> <span class="kw">hiding</span> ((<span class="fu">&lt;|&gt;</span>), many)
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Monad</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Maybe</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Text.ParserCombinators.Parsec</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> parser ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
<span class="fu">&gt;</span> parser <span class="fu">=</span> catMaybes <span class="fu">&lt;$&gt;</span> manyTill bodyguard eof</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> bodyguard ::</span> <span class="dt">Parser</span> (<span class="dt">Maybe</span> <span class="dt">Char</span>)
<span class="fu">&gt;</span> bodyguard <span class="fu">=</span> <span class="kw">Just</span> <span class="fu">&lt;$&gt;</span> try body <span class="fu">&lt;|&gt;</span> eof <span class="fu">*&gt;</span> <span class="fu">return</span> <span class="kw">Nothing</span>
<span class="fu">&gt;</span>                               <span class="fu">&lt;|&gt;</span> anyChar <span class="fu">*&gt;</span> bodyguard</code></pre>
<p>Using Control.Applicative's <code>(&lt;*)</code> and <code>(*&gt;)</code> operators, we can return the middle character while defining the entire expression to attempt to parse.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> body ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
<span class="fu">&gt;</span> body <span class="fu">=</span> lower <span class="fu">*&gt;</span> block <span class="fu">*&gt;</span> lower <span class="fu">&lt;*</span> block <span class="fu">&lt;*</span> lower</code></pre>
<p>A block is nothing more than any three uppercase letters in a row.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> block ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
<span class="fu">&gt;</span> block <span class="fu">=</span> replicateM <span class="dv">3</span> upper</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main <span class="fu">=</span> <span class="fu">getContents</span> <span class="fu">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">print</span> <span class="fu">putStrLn</span> <span class="fu">.</span> parse parser <span class="st">&quot;&quot;</span></code></pre>
<h1 id="challenge-04">Challenge 04</h1>
<p>This challenge has us traverse a list of web pages on a wild goose chase of sorts. We start on node <code>12345</code> and each subsequent page has instructions on how to find the next node. To solve this I wrote a very basic web crawler to automatically traverse the list.</p>
<p>While it really wasn't necessary to solve this challenge and definitely lead to a longer solution, I decided to use monads to carry around the immutable and mutable data for practise. This has lead to a very clean solution.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Monad.State</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Monad.Reader</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Char</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Network.HTTP</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Base</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Node</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre>
<p>This is the definition of the <code>Traverse</code> monad. It caries around the base url and tracks which node we're currently on.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">newtype</span> <span class="dt">Traverse</span> a <span class="fu">=</span> <span class="dt">Traverse</span> (<span class="dt">ReaderT</span> <span class="dt">Base</span> (<span class="dt">StateT</span> <span class="dt">Node</span> <span class="dt">IO</span>) a)
<span class="fu">&gt;</span>     <span class="kw">deriving</span> (<span class="kw">Functor</span>, <span class="kw">Applicative</span>, <span class="kw">Monad</span>, <span class="dt">MonadIO</span>, <span class="dt">MonadReader</span> <span class="dt">String</span>, <span class="dt">MonadState</span> <span class="dt">Int</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> execTraverse ::</span> <span class="dt">Traverse</span> a <span class="ot">-&gt;</span> <span class="dt">Base</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="fu">&gt;</span> execTraverse (<span class="dt">Traverse</span> a) base node <span class="fu">=</span> <span class="fu">fst</span> <span class="fu">&lt;$&gt;</span> (<span class="ot">`runStateT`</span> node) (runReaderT a base)</code></pre>
<p>The base URL. The current node is passed in by setting <code>nothing</code>. For example, the first node is <code>linkedlist.php?nothing=12345</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> base ::</span> <span class="dt">Base</span>
<span class="fu">&gt;</span> base <span class="fu">=</span> <span class="st">&quot;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=&quot;</span></code></pre>
<p>Construct the url by concattenating the base url with the current node.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> url ::</span> <span class="dt">Traverse</span> <span class="dt">String</span>
<span class="fu">&gt;</span> url <span class="fu">=</span> liftA2 (<span class="fu">++</span>) ask (<span class="fu">show</span> <span class="fu">&lt;$&gt;</span> get)</code></pre>
<p>Grab the contents of the current page. There is absolutely no error handling here.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> access ::</span> <span class="dt">Traverse</span> <span class="dt">String</span>
<span class="fu">&gt;</span> access <span class="fu">=</span> url <span class="fu">&gt;&gt;=</span> io <span class="fu">.</span> simpleHTTP <span class="fu">.</span> getRequest <span class="fu">&gt;&gt;=</span> io <span class="fu">.</span> getResponseBody</code></pre>
<p>Traverse the list. There only seems to be two kinds of responses to handle: either we are told what the next node is, or we are told that the next node is 1/2 the value of the current node. If we get something else, we've most likely hit the end of the list and we return the message.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> traverse ::</span> <span class="dt">Traverse</span> <span class="dt">String</span>
<span class="fu">&gt;</span> traverse <span class="fu">=</span> trace <span class="fu">&gt;&gt;</span> access <span class="fu">&gt;&gt;=</span> \rsp <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="fu">&gt;</span>     <span class="kw">let</span> next <span class="fu">=</span> <span class="fu">last</span> <span class="fu">$</span> <span class="fu">words</span> rsp
<span class="fu">&gt;</span>     <span class="kw">case</span> rsp <span class="kw">of</span>
<span class="fu">&gt;</span>         <span class="st">&quot;Yes. Divide by two and keep going.&quot;</span> <span class="ot">-&gt;</span> jump (<span class="ot">`div`</span> <span class="dv">2</span>)
<span class="fu">&gt;</span>         _ <span class="fu">|</span> <span class="fu">all</span> <span class="fu">isDigit</span> next <span class="ot">-&gt;</span> follow next
<span class="fu">&gt;</span>           <span class="fu">|</span> <span class="fu">otherwise</span>        <span class="ot">-&gt;</span> <span class="fu">return</span> rsp
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span>     jump f   <span class="fu">=</span> modify f     <span class="fu">&gt;&gt;</span> traverse
<span class="fu">&gt;</span>     follow n <span class="fu">=</span> put (<span class="fu">read</span> n) <span class="fu">&gt;&gt;</span> traverse
<span class="fu">&gt;</span>     trace    <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> io <span class="fu">.</span> <span class="fu">putStrLn</span> <span class="fu">.</span> (<span class="st">&quot;Travelling to node &quot;</span> <span class="fu">++</span>) <span class="fu">.</span> <span class="fu">show</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main <span class="fu">=</span> execTraverse traverse base <span class="dv">12345</span> <span class="fu">&gt;&gt;=</span> <span class="fu">putStrLn</span> <span class="fu">.</span> (<span class="st">&quot;Result: &quot;</span> <span class="fu">++</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> io ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a
<span class="fu">&gt;</span> io <span class="fu">=</span> liftIO</code></pre>
</body>
</html>
